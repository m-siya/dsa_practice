struct Solution;

// ())()()(())((()(()()(((()))((((())((()(())()())(()((((()))()(()))(())()(())(()(((((())((((((()())())(()(()((())()))(()))))))()(()))((((())()()()))()()()(((()(()())(()()(()(()()(((()))))))()()))())())((()()))))))((()))(((()((())()(()()))((())))()()())))))))()))))(()))))()))()))()((())))((()))(()))))))(((()))))))))()(()()()(())((())()))()()(())))()()))(()())()))(((()())()))((())((((()))(()(()(()()()(((())()(((((()))((()(((((())(()()))((((((((()(()(()(()(())))(())(()())())(()((((()(())((()(())))(())))()(((((()(()()(())))))))())(())(())(()()(((())))((()))(((((()))))())))()((()))()))))())))))((())(((((()()))((((())))(((()(()(())())(((()(()(()()()())))())()))((()((())())()()()(((())(((((()((((((()((()())))((((())((()(((((((()(()((()()()(()(()())(()(()()((((())))()(((()())))(()()))()(()()()()(((((())(()))))((()))())))()((((((()))())))()(()))(())))((((()())(((((()()())(((((())(()())(()))))()(()()))()))))))())))(((())(()(()()))(()))()(((())))())((((()(((()))))))()(()(()))()()(()()))))))))((()))))))(())((()((()))()))((((((()())))))(()((())((((()))))(()(()()()()(()))()()(()(()))(()()(((((((()())(())(()())((())())()(()())((())()())())(()())))())))(())())())(())((()())(((()()))()))()()))()(()(())((((((((())))()((())((()((((((((((()))))(()(((((())(()(()())())))((())())))))()))(()((()()))((()((())()()()((()(())())((())())(()()(((())))))())()()(()))()())(()(()((())))((((()()(())))())(())(()(()(())())())(()()())()(())())))(()()(((())))((()()(((())()()(()())((((()()(()())(()((((()(()()(()(()(((()((()())(()()))(()((((()(((((()))))()()))(((()((((((()(()()()()())()))(()(())))))((()(((()())())))(((()()))(()(()(((((((()()))(()(())))())()(())())(())(()))(())(()))()()(()()())))))()))()((())(((()((((((((())()()))())))((()())(

impl Solution {
    pub fn longest_valid_parentheses(s: String) -> i32 {
        let mut st: Vec<i32> = Vec::with_capacity(s.len() / 2);
        let mut open_count = 1i32; // How open is this string
        let mut max_count = 0;
        for c in s.bytes() {
            if c == b')' {
                if st.pop().is_none() {
                    max_count = max_count.max(open_count - 1);
                    open_count = 1;
                }
            } else {
                st.push(open_count);
                open_count += 1;
            }
        }

        st.push(open_count);

        println!("{st:?}");

        max_count = max_count.max(Self::calc_max_subarr(&st));

        max_count * 2
    }

    fn calc_max_subarr(st: &[i32]) -> i32 {
        let mut prev = 0;
        let mut max_count = 0;
        for &open_brack in st {
            max_count = max_count.max(open_brack as i32 - prev as i32 - 1);
            prev = open_brack;
        }

        max_count
    }
}
fn main() {
    println!("Hello, world!");
}
